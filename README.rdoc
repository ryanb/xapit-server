= Xapit Server

IMPORTANT: This project is currently vaporware.

For an alternative solution see Xapit Sync.

http://github.com/ryanb/xapit-sync/tree/master


== Xapit

Xapit is a Ruby library for interacting with Xapian, a full-text search engine.

http://github.com/ryanb/xapit/tree/master


== How it Works

Xapit Server provides a Rack application which hosts a writable Xapian database and allows interaction through a REST API. Xapit will use this remote database for all search queries and record updates.

There are several advantages to this solution.

* all records will be updated instantly so you do not have to worry about syncing the database.
* the database is only loaded into memory once, not separately for each Rails process. This is very important if you have a large database.
* allows the Xapian database to be stored on a separate machine than the application.
* completely independent of Rails, so you can use it with other Ruby applications.

Here are some disadvantages when compared to Xapit Sync.

* additional security issues (if Rack server is exposed).
* requires a separate daemon process to constantly be running (and monitored).
* more overall traffic to/from the external process.
* greater overhead to perform search requests.
* more difficult to test in staging/development.


== Setup

To use this plugin you simply have to setup a rack server. If you are using Phusion Passenger it may look like this.

  <VirtualHost *:80>
    ServerName xapit-server.example.com
    DocumentRoot /path/to/xapit-server/public
  </VirtualHost>


Then configure Xapit to use this server by passing the URL to the database path.

  # in config/initializers/setup_xapit.rb
  Xapit::Config.setup(:database_path => "http://xapit-server.example.com")


== Implementation

This solution requires a more complex implementation than Xapit Sync. Not all Xapian classes are easily serialized. This may require Xapit to take extra steps to minimize the amount of traffic to the REST API.

=== Commands

Here are some ideas on how the REST api will work.

==== POST /documents

Create a new document index using the POST attributes.

* id: any unique string value to identify this record.
* terms: a comma separated list of terms. Weight for each will be "1".
* data: custom data to fetch through the show action
* weights: a comma separated list of weights which should parallel terms.
* values: a comma separated list of values.
* value_indexes: a comma separated list of value indexes, defaults to incrementing numbers starting with zero.
* spellings: a comma separated list of spellings to add along with the document. There is another interface to add spellings but this is for convenience.

==== GET /documents/:id

Returns the custom data stored in the document at the given id.

==== PUT /documents/:id

Update an existing document index. The attributes passed are the same as creating a document except the +id+ attribute is not allowed.

==== DELETE /documents/:id

Deletes the document matching that id.

==== POST /queries

Pass in a query and get a list of matching document ids and percentages in response. While this technically should be a GET request since nothing changes on the server, the query parameter may be very long, so a POST request is necessary.

* query: serialized Xapian::Query
* sort: a comma separated list of values to sort by
* descending: to sort in descending order (true/false)
* offset: where to start the fetching
* limit: how many documents to fetch
* collapse_key: the key to collapse

==== POST /spellings

* spellings: a comma separated list of terms to add to the spelling dictionary.

==== GET /spellings

Returns spellings suggestions given a term.
